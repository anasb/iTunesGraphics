<html>
<title>Twitter Graphics</title>
<body>
<center><h2>Computer Graphics - Anas Bouzoubaa Final Project</h2></center>
<br/>

<link href="style/style.css" rel="stylesheet" type="text/css">
<script src="js/script.js"></script>
<script src="js/three.min.js"></script>
<script src="js/AnaglyphEffect.js"></script>
<script src="js/CSS3DRenderer.js"></script>
<script src="js/Projector.js"></script>

<center>
<div id='container'>
</div>
</center>

<script>
	this.scene = new THREE.Scene();

    var container, renderer, effect;
    var anaglyphIsOn    = false;
    var animated        = false;

    // CAMERA
    var SCREEN_WIDTH, SCREEN_HEIGHT, VIEW_ANGLE, ASPECT, NEAR, FAR, camera;
    SCREEN_WIDTH = 0.85 * screen.width;
    SCREEN_HEIGHT = 0.8 * screen.height;
    VIEW_ANGLE = 45,
    ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT,
    NEAR = 0.1, 
    FAR = 20000;
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
    scene.add(camera);
    camera.position.set(0,150,400);
    camera.lookAt(scene.position);

    // RENDERER
	container = document.getElementById('container');
    renderer = new THREE.WebGLRenderer();
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    container.appendChild(renderer.domElement);
    renderer.setClearColor( 0xffffff, 1);
    renderer.shadowMapEnabled = true;
    renderer.shadowMapType = THREE.PCFSoftShadowMap;
    renderer.domElement.style.margin = '0 auto';
    document.body.appendChild( renderer.domElement );
    
    // For 3D
    if (anaglyphIsOn) {
        effect = new THREE.AnaglyphEffect(renderer);
        effect.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    }
    
    // LIGHT
    var light = new THREE.SpotLight( 0xffffff );
    // light.shadowCameraVisible = true; // for debugging light
    light.position.set( 600, 1000, 0 );
    light.distance = 100;
    light.castShadow = true;
    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;
    light.shadowCameraNear = NEAR;
    light.shadowCameraFar = FAR;
    light.shadowCameraFov = 30;
    light.shadowDarkness = 0.5;
    scene.add(light);

    // PLANE
    var floorTexture, floorMaterial, floorGeometry, floor;
    floorTexture = THREE.ImageUtils.loadTexture("textures/metal.jpg");
    floorTexture.needsUpdate = true;
    floorTexture.wrapS = floorTexture.wrapT = THREE.ClampToEdgeWrapping;
    floorTexture.minFilter = THREE.NearestFilter;
    floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    floorGeometry = new THREE.PlaneBufferGeometry(1000, 1000, 10, 10);
    floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.5;
    floor.rotation.x = Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Tweet
    // var tweetMaterial, tweetGeometry, tweet;
    // tweetMaterial = new THREE.MeshBasicMaterial({ color:0x55ACEE });
    // tweetGeometry = new THREE.PlaneBufferGeometry(100, 100, 1, 1);
    // tweet = new THREE.Mesh(tweetGeometry, tweetMaterial);
    // tweet.position.x = -200;
    // tweet.position.y = 1;
    // tweet.receiveShadow = true;
    // scene.add(tweet);

    // CSS3D
    //-----------------------------------------------------------

    // HTML Plane
    var planeMaterial   = new THREE.MeshBasicMaterial({color: 0x55ACEE, opacity: 0.1, side: THREE.DoubleSide });
    var planeWidth = 250;
    var planeHeight = 100;
    var planeGeometry = new THREE.PlaneBufferGeometry( planeWidth, planeHeight );
    var planeMesh= new THREE.Mesh( planeGeometry, planeMaterial );
    planeMesh.position.y += planeHeight/2;
    scene.add(planeMesh);

    // CSS Scene
    var cssScene = new THREE.Scene();
    var element = document.createElement('iframe')
    element.src = "pages/profile.html";
    var elementWidth = SCREEN_WIDTH;
    var aspectRatio = planeHeight / planeWidth;
    var elementHeight = SCREEN_HEIGHT; //elementWidth * aspectRatio;
    element.style.width  = elementWidth + "px";
    element.style.height = elementHeight + "px";
    
    // CSS Object
    var cssObject = new THREE.CSS3DObject( element );
    cssObject.position = planeMesh.position;
    cssObject.rotation = planeMesh.rotation;
    var percentBorder = 0.05;
    cssObject.scale.x /= (1 + percentBorder) * (elementWidth / planeWidth);
    cssObject.scale.y /= (1 + percentBorder) * (elementWidth / planeWidth);
    cssScene.add(cssObject);
    
    // create a renderer for CSS
    rendererCSS = new THREE.CSS3DRenderer();
    rendererCSS.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
    // rendererCSS.domElement.style.position = 'absolute';
    // rendererCSS.domElement.style.top      = 0;
    // rendererCSS.domElement.style.margin   = 0;
    // rendererCSS.domElement.style.padding  = 0;
    document.body.appendChild( rendererCSS.domElement );

    // renderer.domElement.style.position = 'absolute';
    // renderer.domElement.style.top      = 50;
    // renderer.domElement.style.zIndex   = 1;
    // rendererCSS.domElement.appendChild( renderer.domElement );
    //-----------------------------------------------------------

	// CUBE
    var cubeTexture, cubeMaterial, cubeGeometry, cube;
	cubeTexture = THREE.ImageUtils.loadTexture("textures/funky.jpg");
    cubeTexture.needsUpdate = true;
    cubeTexture.wrapS = cubeTexture.wrapT = THREE.ClampToEdgeWrapping;
    cubeTexture.minFilter = THREE.NearestFilter;
    cubeMaterial = new THREE.MeshBasicMaterial({ map: cubeTexture, side: THREE.DoubleSide });
    cubeGeometry = new THREE.BoxGeometry(100, 100, 100);
	cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
    cube.position.z = -100;
    cube.rotation.x = 1;
    cube.rotation.y = 1;
    cube.castShadow = true;
	// floor.add(cube);

	// RENDER
	var render = function () {
		time = (new Date().getTime()) / 1000;
	 	requestAnimationFrame( render );

        // Animate stuff
        if (animated) {
    	    cube.position.z = -100 + 20 * Math.sin(time);
        }

        // Render scene
        if (!anaglyphIsOn) {
            renderer.render(scene, camera);
        } else {
            effect.render(scene, camera);
        }
	};
	render();
</script>
</body>
</html>
